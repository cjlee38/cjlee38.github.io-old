---
layout: post
title:  "# 백준[No.2477] - 참외밭 ( python )"
date:   2020-08-23 22:41:00 +0900
categories: problem-solving
tags: baekjoon
author: cjlee
cover: /assets/covers/coding.png
---

[문제 링크](https://www.acmicpc.net/problem/2477)

# PROBLEM

![1](/assets/images/2020-08-27-09-19-12_2020-08-27-ps_2.md.png){: .alignCenter}
![2](/assets/images/2020-08-27-09-20-02_2020-08-27-ps_2.md.png){: .alignCenter}
# SOLVE

### ** 1) 주의사항**

: 해당 문제에서 주의해야 할 요소는 다음과 같다.

-   참외밭은 ㄱ자 모양, 혹은 이를 회전한 ┏, ┗, ┛ 모양의 육각형이다.
-   참외밭의 둘레를 돌면서 지나는 변의 방향은 **반시계방향**으로 주어진다.
-   변의 방향은 동,서,남,북 순서로 1,2,3,4의 값을 가진다.
-   **출발 꼭지점은 "임의"로 주어진다.**

### **2) 해결법**

: 처음 문제를 보았을 때, 위 두가지 방법이 떠올랐다.

 1. 해당 모형의 육각형을 3등분하여 각 넓이를 구한뒤, 합산한다.

 2. 육각형을 직사각형의 모양으로 확장한 뒤, 비어 있는 부분을 분리해낸다.

 1번 방법은 코드로 구현해낼 수 있는 방법이 떠오르지 않았고, 2번 방법이 정답으로 보였는데, 당최 어떻게 해야 할지 고민하다가, 다음과 같은 규칙성을 찾아낼 수 있었다. 풀이법을 상술하기 전에, 먼저 "전체 박스는 큰 박스, 비어 있는 부분은 작은 박스"로 명명하자.

** A. 큰 박스의 넓이를 구하는 법**

 먼저, 해당 그림은 "육각형"이므로 6개의 변을 갖는다. 그리고 각 변은 동서남북의 네 방향으로만 움직인다. 따라서, 그림의 모양을 살펴보면, **"동서남북의 방향으로 이동하는 변이 한 번만 등장할 경우, 해당 변이 가로, 혹은 세로의 전체 길이"**라는 것을 알 수 있다.

따라서, 위 예시로 나타난 그림에서, 단 한번만 등장하는 "방향"은 4, 2번의 북, 서 방향이고, 따라서 세로 50, 가로 160의 길이임을 확인할 수 있다.

** B. 작은 박스의 넓이를 구하는 법**

 작은 박스의 변을 구하려면, 가로 60, 세로 20의 변을 도출해내야 한다. 그런데, 큰 박스를 구할 때 사용한 4 50과 2 160을 제외한 나머지로는 구하기가 영 어려워 보인다. 게다가, ㄱ자 모양만 갖는 것이 아니라, 위에서 언급한 4가지의 모양을 가지고, 게다가 "임의의" 점에서 출발하기 때문에, 나머지 네 변만을 이용하여 작은 박스의 가로 세로를 구할 수는 없다.

 그러나, 출발점에서 선을 그려나간 이후에, 최종적으로 본래의 점으로 돌아오기 때문에, **Circular Linked List**로 생각해 볼 수 있다. 

 또, 그림을 유심히 보면, **"큰 박스의 가로 혹은 세로 길이의 변에서, 세 번째 이동하는 변이 작은 박스의 세로 혹은 가로 변이다"**는 것을 알 수 있다.

 즉,

 큰 박스의 세로 변 4 50 이후, 다음 세 번째 변은 작은 박스의 가로 변 60이고,

 큰 박스의 가로 변 2 160 이후, 다음 세 번째 변은 작은 박스의 세로 변 20이다.

** C. 최종 답**

 따라서, **최종 답 = ( 1m^2 당 참외 개수 K ) \* ( 큰 박스 넓이 - 작은 박스 넓이 )** 로 답을 구해낼 수 있다. 이를 코드로 구현하면 다음과 같다.

### ** 3) 구현**

```python
melon = int(input()) # 참외 개수 K
values = [input().split() for _ in range(6)] # 나머지 2~7 line의 6 줄을 입력 받는다.
directions = [int(v[0]) for v in values] # 방향을 뽑아내서 저장한다.
lengths = [int(v[1]) for v in values] # 길이를 뽑아내서 저장한다.
max_lengths, box_lengths = [], [] # 큰 박스의 길이, 작은 박스의 길이를 담을 배열

for i in range(1, 5):
    if directions.count(i) == 1: # direction이 한번만 존재한다 == 큰 박스의 변
        max_lengths.append(lengths[directions.index(i)]) # 큰박스의 변 길이 저장
        temp = directions.index(i) + 3 # 큰 박스 + 3 == 작은 박스의 변
        if temp >= 6:
            temp -= 6 # cycle을 위해 6 이상일 경우 -6
        box_lengths.append(lengths[temp]) 

area = max_lengths[0] * max_lengths[1] - box_lengths[0] * box_lengths[1]
print(melon * area)
```

위 코드를 통해 문제를 해결할 수 있었다.

### ** 4) 아쉬운 점.**

 1. 좀 더 우아하게 코드를 작성할 수 있을 것 같은데, 파이썬에서는 Circular Linked List의 library가 존재하지 않아서 ( itertools의 cycle을 이용하는 방법이나, 직접 Circular Linked List를 구현할 수도 있지만, 배보다 배꼽이 커지는 격일 것 같아서 하지 않았다.  어떻게 하면 더 pythonic하게 구현할 수 있었을까? 흠.. 아무래도 아쉽다

 2. 규칙성을 발견한게 우연의 산물인 것 같아서 조금 아쉽다. 근거에 기반하여 규칙성을 발견해낸 것이 아니라, **"그렇게 규칙이 있으니까"** 이를 구현한 것이 아무래도 찝찝하다. 혹여 누군가가 개선점을 발견한다면, 꼭 한마디 남겨주면 고맙겠다. 끝