---
layout: post
title:  "# 마음으로 이해하는 알고리즘 : LIS의 길이구하기 ( feat. Java )"
date: 2020-12-15 13:57:00 +0900
categories: algorithm
tags: 
author: cjlee
cover: /assets/covers/coding.png
---

<center>
<iframe src="https://giphy.com/embed/3o6Yg4GUVgIUg3bf7W" width="480" height="205" frameBorder="0" class="giphy-embed" allowFullScreen></iframe><p><a href="https://giphy.com/gifs/producthunt-zach-galifianakis-algorithm-3o6Yg4GUVgIUg3bf7W"></a></p>
</center>

# 0. 들어가며
: 누군가는 라면받침대라고 표현하는 종만북을 도서관에서 빌려봤다. 생각보다 너무 어려운 난이도에 책장을 넘기던 중, 어디선가 많이 주워들은 LIS 문제를 보고, 이것만큼은 이해해보자는 생각으로 한참을 들여다봤다. 나름대로 설명하는 페이지는 많았으나, 내 입맛에 맞게 설명해주는 그리 많지 않아, 혹여라도 나처럼 머리가 좋지 않아 고생하는 분들이 계실까 해서, 정말 극한으로 풀어서(≒구구절절) 설명해보고자 한다.

아무래도 양이 꽤 될 것 같아, 나에게도, 읽는 분에게도 꽤 험난한 여정이 될 것이라 사료된다. 날도 추운데 옆에 커피라도 한잔 놓고 읽어보는 것을 권장한다.

<!-- 이해하는데 도움이 됐습니다. 감사합니다. -->

# 1. 해결할 문제
: LIS는 Longest Increasing Subsequence의 약자로, 한국말로 번역하면 "최대 증가 부분 수열" 정도가 된다. 즉, 정수의 수열 S 가 주어졌을 때, S 에서 0개 이상의 숫자를 지우고 남은 수열을 "부분 수열" 이라고 칭하고, 그 수열 중에서 "오름차순으로 정렬" 된 수열을 "증가 부분 수열", 그리고 그 중에서 가장 긴 수열을 **"최대 증가 부분 수열"** 이라고 한다.

말로 하면 약간 헷갈리니, 다음의 예시를 보자. 앞으로 이 예시를 계속 사용할 것이다.

<center> [3 5 7 9 2 1 4 8] </center>
<br>

* 부분 수열의 예 : [3 8 9 2 1 4]
* 증가 부분 수열의 예 : [1 4 8]
* 최대 증가 부분 수열의 예: [3 5 7 8]

이 때, 최대 증가 부분 수열(이하, LIS) 또한 여러 개가 될 수 있다. (현 예에서는 [3 5 7 8] 이외에 [3 5 7 9] 또한 존재한다.) 그러나, 우리가 원하는 것은 "LIS 의 길이" 하나 이므로, 몇 개가 존재하던 상관이 없다.

# 2. 첫 번째 방법 - 완전탐색

### 2-A 이론
: 사람이라면 몇 번 훑어보면 금방 찾을 수 있지만, 알다시피 컴퓨터는 우리 생각만큼 똑똑하지 않다. 나도 그랬듯이, 이 문제를 코딩으로 해결하고자 할 때 떠올릴 수 있는 방법은, 모든 경우를 탐색하는 것, 즉 **완전탐색**이다.

완전탐색을 이해하는 것은 그리 어렵지 않다. 말로 자세히 풀어서 설명하기보단, 다음의 순서를 반복하는 것을 이해하는 것이 더 간단할 것 같다.

1. 주어진 배열(= 부분수열)에서, 하나의 요소 **X** 를 선택한다.
2. X 뒤쪽의 배열을 살펴보면서, **X 보다 크면 이를 다음 탐색할 배열 A** 에 넣는다.
3. 배열 A 를 가지고, 1번을 반복한다.
4. 만약 배열 A 가 비어 있는 경우, 재귀함수를 종료(스택을 하나 제거)하면서 0 을 return한다.

그림으로 표현하자면, 다음과 같다.

![](/assets/images/2020-12-15-14-45-55_2020-12-15-ways_to_get_LIS_length.md.png)

**[3 5 7 9 2 1 4 8]** 이라는 배열이 주어져있고, **3 을 X** 로 지정했다.  
그리고 나서, 그 뒤쪽의 배열 중, 3 보다 큰 녀석들(빨간박스) 을 새로운 배열로 만든다.

![](/assets/images/2020-12-15-14-47-27_2020-12-15-ways_to_get_LIS_length.md.png)

그리고 이렇게 **[5 7 9 4 8]** 을 가지고, 또 다시 **5 를 X**로 지정했다.  
다시 그 뒤쪽을 살펴보면서, [7 9 8] 을 새로운 배열로 만든다.

이러한 과정을 반복하면서, 배열이 비어 있는 경우, 0 을 return 하면 된다.  
살짝 머리가 아파지니, 그윽한 자바코드 냄새를 맡으면서 환기해보자.

### 2-B 구현

```java
public int lis1(List<Integer> list) {
    if (list.isEmpty()) return 0;

    int ret = 0;
    for(int i = 0; i < list.size(); i++) {
        List<Integer> sub = new ArrayList<>();
        for (int j = i+1; j < list.size(); j++) {
            if (list.get(i) < list.get(j)) {
                sub.add(list.get(j));
            }
        }

        ret = Math.max(ret, lis1(sub) + 1);
    }

    return ret;
}
```
하나씩 살펴보자.

```java
if (list.isEmpty()) return 0;
```

리스트(배열)가 비어있는 경우에 0 을 돌려주는 것은 당연하다. 처음으로 주어진 배열 자체가 아예 비어있다면 LIS 의 길이 또한 0 이 될 것이며, 재귀함수의 호출 과정속에서도 배열이 비어있다는 것 또한 마찬가지로 LIS 의 길이가 0 이라는 것을 의미하기 때문이다. 이와 더불어, 재귀함수를 종료할 base case(기저사례) 이기도 하다.

```java
for(int i = 0; i < list.size(); i++) {
    List<Integer> sub = new ArrayList<>();
    for (int j = i+1; j < list.size(); j++) {
        if (list.get(i) < list.get(j)) {
            sub.add(list.get(j));
        }
    }
}
```
ret은 잠시 미뤄두고, 다음으로 주목할 부분은 for-loop 다. 0 번째부터 시작하는, 하나의 요소 X를 선택한 뒤(=`list.get(i)`), 그 뒤쪽의 값과 비교하면서, 만약 뒤쪽의 값이 더 크다면 이를 `sub` 라는 리스트에 추가한다.

```java
int ret = 0;

for ( i... ) {
    for ( j... ) {

    }
    ret = Math.max(ret, lis1(sub) + 1);
}

return ret;
```

그 다음으로 살펴볼 부분은 변수 ret 이다. 주목해야 할 부분은 `ret = Math.max(ret, lis1(sub) + 1);` 이 부분인데, 우리가 재귀함수를 열심히 쌓다가, 이제는 우리가 헤어져야 할 시간이 되면 0 이 return 된다. 

애초에 base case 에서부터 1 을 return 하지 않고, **0 을 return 하는 대신 여기에 + 1 을 넣어준 이유**는, 

1. 원본의 배열이 애초에 비어 있을 때 0 을 return 하는게 타당하면서,
2. 동시에, 재귀함수를 호출하던 과정 속에서 배열이 비어있을 때 또한 길이가 0 임을 의미히기도 하고,
3. 이와 더불어 "어차피 우리가 선택한 sub 배열은 나보다 큰 녀석" 이고, 이는 곧 증가 부분 수열의 길이가 반드시 1 (혹은 그 이상) 늘어난다는 것을 의미하기 때문이다.

---
> 3 번이 헷갈리는 사람(나)을 위해, 다음과 같은 부연설명을 읊조려보자면,  
> 가령 원 배열이 [1 2] 가 있다고 해보자. 그렇다면, 첫 번째 재귀함수 과정 속에서 sub 에 2 가 들어갈 것이고, 두 번째 재귀함수 내에서 [2] 는 다시 아무것도 없는 배열 [] 를 호출할 것이다.   
> 세 번째 재귀함수에선, 배열에 아무것도 들어있지 않으므로 0 이 return 될 것이고, 다시 두 번째 재귀함수로 돌아왔을 때에는 for-loop 내에서 `ret = Math.max(0, 0+1);` 이 된다. for-loop 가 더 이상 나아갈 수 없으므로 1 을 그대로 return 하고, 첫 번째 재귀함수에서 마찬가지로 `ret = Math.max(0, 1+1);` 이 된다. i 가 1(즉, X 가 2인 경우) 에는 위와 같은 과정을 통해 1 이 return 될 것이고, `Math.max(2, 1)` 를 통해 최종적으로 2 가 return 된다.  
> 여전히 이해가 되지 않는다면, 반대로 [2 1] 인 경우를 상상해보자.

---

### 2-C 시간복잡도
: 이러한 완전탐색의 시간복잡도는 얼마나 될까? 대부분의 시간복잡도가 최악의 상황을 가정하니, 이 알고리즘에 최악이 될 수 있는 상황을 가정해보자. 아무래도 sub가 많아지면 많아질수록 최악이 될테니, [1 2 3 4 5 6 ...] 과 이미 오름차순으로 정렬되었을 때가 가장 오래 걸릴 듯 싶다.

배열을 하나씩 늘려가면서 함수가 호출되는 횟수를 살펴보자.(for문은 재귀함수의 호출로 연결된다는 점을 생각하자.)
* [] -> 1
* [1] -> 2
* [1 2] -> 4
* [1 2 3] -> 8

![](/assets/images/2020-12-15-15-23-11_2020-12-15-ways_to_get_LIS_length.md.png)


패턴이 보인다. O(2^n) 이다. 통상적으로 O(n^2) 이어도 상당히 곤란한 시간복잡도인데, O(2^n) 이라고 하면 척 봐도 비효율적인 것 처럼 보인다.

# 3. 두 번째 방법 - 동적계획법
: 위에서 살펴본 완전탐색이 비효율적인 이유는, 역시 **같은 연산을 반복**하기 때문이었다. 이전에 작성했던 [재귀함수 글](https://cjlee38.github.io/btb/recursive_function) 에서 보았던 것처럼, 동적계획법을 이용해보자. 이렇게 동적계획법을 떠올릴 수 있는 기저는, 이 문제가 **최적부분구조**를 갖고 있기 때문이다. 

메모이제이션, 캐시 등 관점에 따라 다른 이름으로 부르지만, 어쨌든 여기서 중요시하는 내용은 **"한번 계산한 부분은, 또 다시 계산하지 않는다." 는 것이 핵심**이다. 바로 위의 사진에서 보듯이, 배열이 비어있을 때를 중복으로 쳐다보기도 하지만, 배열이 [3]과 같은 부분도 중복해서 연산을 하는 것을 볼 수 있다.

즉, [3] 의 꼬리를 잘라내보자.

### 3-A. 이론
: 단순하게 동적계획법을 생각하면 어렵지 않을 것 같다. "처음 계산이면 캐시에 저장, 한번이라도 본 적이 있다면 꺼내서 사용" 하면 된다. 다만, 막상 코드로 쓰려고 키보드에 손을 올리는 순간 멈칫하게 된다. "캐시를 어떻게 만들어놓지?"

이 때 우리가 기억해야 할 점은, 하나의 요소 X 를 골랐을 때, 앞에서 어떤 배열이 넘어왔든, 그 뒤쪽의 sub는 항상 같다는 점이다. 즉, [3 5 7 9 2 1 4 8] 라는 배열에서, 우리가 7 이라는 요소를 선택했을 때, 그 sub 가 될 수 있는 [9 8]은 언제나 동일하다. 이는 그 전의 호출에서 3의 선택으로 [5 7 9 4 8]이 넘어왔든, 5의 선택으로 [7 9 8]이 넘어왔든, 이번에 7 이 선택되었으면 그 sub가 되는 [9 8]은 항상 동일하다는 것이다.

![](/assets/images/2020-12-15-15-58-53_2020-12-15-ways_to_get_LIS_length.md.png)

이를 다시 바꿔서 이해해보자. 우리가 7 을 선택했을 때, 즉 index 상으로 2 번을 선택했을 때 해당 증가 부분 수열의 길이가 계산되어 있다면, 그 값을 return 하면 된다. 계산되어 있지 않다면, 기존에 하던대로 계산하면 된다.


### 3-B 구현

: 위 아이디어를 코드로 구현하기 이전에, 몇 가지 작업을 해둘 부분이 있다.

먼저, 리스트의 가장 앞부분에 -1 을 넣어두자.(현재 예제는 자연수를 기준으로 하고 있기 때문에, 정수를 고려할 경우 `Integer.MIN_VALUE`를 넣어야 한다.) 이 내용은 조금 밑에서 설명하겠다.

```java
list.add(0, Integer.MIN_VALUE);
```

그 다음으로, cache를 -1로 초기화 해놓자.
```java
List<Integer> cache = new ArrayList<>();
for (int i = 0; i < list.size(); i++) {
    cache.add(-1);
}
```
-1 로 초기화해놓는 이유는, 기존의 list 와 쌍을 맞춰주기 위함이면서, 동시에 **LIS 가 빈 배열로 인해 0 이 될 수도 있으니, 이를 구분하기 위해 -1 로 초기화 해두겠다**는 것이다.

```java
public int lis2(List<Integer> list, List<Integer> cache, int start) {
    if (cache.get(start) != -1) return cache.get(start);

    int ret = 0;
    for(int next = start+1; next < list.size(); next++) {
        if (list.get(start) < list.get(next)) {
            ret = Math.max(ret, lis2(list, cache, next) + 1);
        }

    }
    cache.set(start, ret);

    return ret;
}
```

---

> 여기서 잠깐, 기존 코드와의 통일성을 위해 List를 사용하였지만, 이번에는 list 와 cache의 크기가 고정되어 있기 때문에(앞서는 sub에 따라 크기가 달라졌다.), 단순히 array를 사용해도 상관 없다.


---
뭔가 기존 코드와 비슷하면서도 사뭇 다른 부분이 몇가지 보인다. 이 또한 하나씩 뜯어보자.

```java
if (cache.get(start) != -1) return cache.get(start);
```
가장 간단해 보이는 이 부분은 캐시에 저장된 부분이 있다면, 그 부분을 가져오겠다는 의미가 된다.

```java
public int lis2(List<Integer> list, List<Integer> cache, int start)
```
그 다음으로 눈에 띄는 부분은, 함수가 받고자 하는 파라미터가 조금 변화하였다. 이 부분이 가벼워 보이지만 신중하게 바라봐야 하는 이유는, 바로 start 변수에 있다. 우리가 cache를 사용하려면, index를 기반으로 접근해야 한다. 그리고 이 index를 사용하기 위해서는, **항상 리스트의 길이는 고정되어야 한다.** 말인 즉슨, sub 배열을 만들어줘서는 안된다는 뜻이다. 

sub 배열을 만들게 될 경우, 우리가 for-loop에서 사용할 index가 뒤틀리는 문제가 발생하게 된다. 반대로, sub 배열을 만들지 않고 원본 list를 사용하지 않더라도 전혀 문제가 되지 않는다. 왜냐하면, 우리가 사용하는 index 는 **"앞의 내용을 전혀 신경쓰지 않아도" 되기 때문**이다. 

위에서 작성한 내용을 다시 살펴보자.

---

> 이 때 우리가 기억해야 할 점은, 하나의 요소 X 를 골랐을 때, 앞에서 어떤 배열이 넘어왔든, 그 뒤쪽의 sub는 항상 같다는 점이다.


---

```java
for(int next = start+1; next < list.size(); next++) {
    if (list.get(start) < list.get(next)) {
        ret = Math.max(ret, lis2(list, cache, next) + 1);
    }

}
```

이에 맞춰서 for-loop 도 변화하였다. 우리는 리스트를 인덱스를 기준으로 살펴볼 것이므로, next 는 start + 1 부터 시작한다. 그리고 와중에 **"나보다 큰 녀석"을 발견**하면, **그 녀석을 대상으로 다시 재귀함수를 호출**하게 된다. 재귀함수의 결과에 더하는 1 은 앞에서 설명했으니 생략하겠다.

또한, 만약 cache에서 답을 구하지 못하고, LIS 가 마지막으로 가더라도 상관없다. 자연스럽게 for-loop 의 조건에 성립하지 않으므로, 0 이 return 된다. 즉, 이전 코드의 `if (list.isEmpty()) return 0;` 와 같은 base case를 **특별히 명시해둘 필요가 없는 것**이다.

```java
cache.set(start, ret);

return ret;
```
처음 문제를 마주한 경우에는 당연히 cache를 저장하고, 그 값을 돌려주면 된다.

그런데, 단순히 이렇게만 봤을때에 문제가 하나 있다. 바로 **0 번째 인덱스가 가장 큰 값인 경우를 해결하지 못한다는 것이다.** 그 이유는, 재귀함수를 처음 호출했을 때, if 문에 걸리지 않기 때문이다. 이를 위해 `list.add(0, Integer.MIN_VALUE);` 를 넣었던 것이다. 

**다른 방법으로는,** 

애초에 `lis2()` 함수 자체를 한번 더 묶어서, 

```java
int max = 0;
for (int i = 0; i < n; i++) {
    max = Math.max(max, lis2(...));
}
```

처럼 사용하는 방법이 있다. 이 방식은 `lis2()` 의 반복을 밖에서 하느냐, 안에서 하느냐의 차이이지, 본질적으로는 같다. 다만, `ret = 0` 을 `ret = 1`로 바꾸어 주어야 한다. 또한, cache의 내용은 달라진다 

* 0번 index에 값을 넣어주는 방법-> [4 3 2 1 0 2 2 1 0]
* 바깥쪽에서 loop를 돌려주는 방법 -> [4 3 2 1 3 3 2 1]


### 3-C 시간복잡도
: 아까 2-C 에서 보았던 꼬리란 꼬리는 다 끊어놓았기 때문에, 해당 코드는 결국 까보면 2중의 for-loop를 반복하게 된다. 따라서 시간복잡도는 O(n^2) 이 된다.


# 4. 세 번째 방법 - 동적계획법 2
: 엥? 두 번째도 동적 계획법이었는데, 세 번쨰도 동적 계획법이라니 약간 당황스럽다. 하지만 읽어보면, 둘 다 동적계획법의 정신을 계승하는 알고리즘이란 것을 알 수 있다.

### 4-A 이론
: 이번에는 조금 관점을 달리하자. 재귀함수를 호출하기 보다는, 두 개의 for-loop 로 해결할 것이다. 어떻게 할 것이냐?

이는 배열의 요소를 하나씩 살펴보면서, **"내가 될 수 있는 증가부분수열의 최대값은 몇이냐?"** 를 보는 것이다. 아까는, cache에서, LIS 의 시초가 되는 녀석이 부분증가수열의 최대값이 되었다면, 지금은 **LIS 의 유종의 미를 거두어주는 녀석이 부분증가수열의 최대값**이 된다.

즉,
* 전자의 경우 -> [4 3 2 1 3 3 2 1]
* 후자의 경우 -> [1 2 3 4 1 1 2 4]

가 된다.

이를 어떻게 만드는고 하니, 아주 간단하게 다음과 같은 아이디어를 적용하면 된다

* 현재 내 값 X 를 기준으로 앞쪽을 봤을 때 나보다 작은 녀석들 중 (즉, 내가 뒤에 붙을 수 있는 후보들) , 증가 부분수열의 길이가 가장 긴 녀석 + 1 이 나의 증가부분수열의 길이.

글재주가 없어 말로 쓰니 헷갈린다. 얼른 예시를 보자.

![](/assets/images/2020-12-15-18-06-24_2020-12-15-ways_to_get_LIS_length.md.png)

편의상 값(Value)를 담았다는 의미로 V 를, 증가부분수열의 길이(Length) 를 담았다는 의미로 L 테이블이라 칭하겠다.

처음에는 이렇게 가장 앞에 0을 붙인채로 초기화한다.

![](/assets/images/2020-12-15-18-07-19_2020-12-15-ways_to_get_LIS_length.md.png)

x 를 3으로 두었을 때, 내 앞에 있으면서, 나보다 작은 녀석은 [0] 하나다. 하나밖에 없으므로 이 녀석의 증가부분수열의 길이 0 에 1을 더한게, 나의 length가 된다.

![](/assets/images/2020-12-15-18-08-52_2020-12-15-ways_to_get_LIS_length.md.png)

마찬가지의 과정을 반복한다. 즉, x 를 9로 두었을 때, 내 앞에 있으면서 나보다 작은 녀석들은 [0 3 5 7] 이다. 그리고 그 중에서, 가장 긴 증가부분수열의 길이를 갖고 있는 3 에 1 을 더한 4 가 나의 length가 된다.

![](/assets/images/2020-12-15-18-10-01_2020-12-15-ways_to_get_LIS_length.md.png)

value 가 2 일 때도 마찬가지이다. x를 2로 두었을 때, 내 앞에 있으면서 나보다 작은 녀석은 [0] 하나다. 하나밖에 없으므로 이 녀석의 증가부분수열의 길이 0 에 1 을 더한게 나의 length, 즉 1이 된다.

![](/assets/images/2020-12-15-18-11-18_2020-12-15-ways_to_get_LIS_length.md.png)

마지막의 경우를 살펴보자. X를 8로 두었을 때, 나보다 작은 녀석은 [3 5 7 2 1 4] 이다. 그리고 그 중, 가장 긴 증가부분수열의 길이를 갖고 있는 녀석은 3(7이 갖고있는) 이고, 여기에 1을 더한 4 가 답이 된다.

이렇게 해서, 4 라는 최종 답을 구할 수 있다.

### 4-B 구현

```java
public int lis3(List<Integer> V) {
    List<Integer> L = new ArrayList<>();

    V.add(0, 0);
    L.add(0);

    int ret = 0;
    for (int i = 1; i < V.size(); i++) {
        int maxLen = 0;
        for (int j = 0; j < i; j++) {
            if (V.get(j) < V.get(i)) {
                maxLen = Math.max(maxLen, L.get(j) + 1);
            }
        }
        L.add(maxLen);
        ret = Math.max(ret, maxLen);
    }

    return ret;
}
```

코드는 그닥 어렵지 않다.
```java
List<Integer> L = new ArrayList<>();

V.add(0, 0);
L.add(0);
int ret = 0;
```

이 내용은 우리가 앞서 봤듯이, 미리 세팅을 해놓는 단계이다.
```java
for (int i = 1; i < V.size(); i++) {
    int maxLen = 0;
    for (int j = 0; j < i; j++) {
        if (V.get(j) < V.get(i)) {
            maxLen = Math.max(maxLen, L.get(j) + 1);
        }
    }
    L.add(maxLen);
    ret = Math.max(ret, maxLen);
}

```
그리고, for-loop 를 돌면서 한 놈씩 잡는다. 그리고 앞쪽을 살펴보면서, 나보다 작은 녀석 중 최대의 길이를 구한 뒤에, 나는 거기에 1 을 더한 값을 갖는다.

정확히 위의 과정과 일치하는 내용이다. 코드가 워낙 간단해서, 뭐라고 내가 몇 마디 떠드는 것보다 코드를 읽는 편이 더 이해하기 수월할 것이다.


### 4-C 시간복잡도.
: 간단하게 2중 for-loop로 이루어져 있으니, 시간복잡도는 O(n^2) 라는 사실을 쉽게 유추할 수 있다.

# 5. 네 번째 방법 - 이진탐색
: 그런데 O(n^2) 방법도 맘에 들지 않는다. 우리는 조금 더 최적화를 하고 싶다. 아마 이 글을 읽는 사람들도 위 세 방법을 이해하지 못해서 여기까지 오진 않았을 것 같다. 글을 읽느라 식어버린 커피를 원샷 때리고, 담배도 한 대 피워본 뒤, 차분하게 읽어보자.

### 5-A 이론
이 알고리즘은 세 번째 방법을 개선한다. 세 번째 방법은, 우리가 뒤쪽으로 가면서 앞쪽에 있는 녀석들을 모두 살펴봐야 했었다. 앞쪽에 있는 녀석들은 하나씩 추가되기도 하고, 나보다 작을수도, 클 수도 있기 때문이다. 그런데, 관점을 살짝 뒤틀어보자.

내가 선택한 X 라는 녀석이 더욱 긴 녀석이 되기 위해서는, 앞에 있는 녀석이 작은 편이 좋다. 가령, [5 6 1 2 X] 라는 배열이 있다고 해보자. 이 녀석들의 L 테이블은 {1 2 1 2} 로 구성되어있을 것은 자명하다. 여기서, X 가 999 라면, [5 6] 과 [1 2] 둘 다 이어갈 수 있지만, X 가 3 이라면 [1 2] 는 이어갈 수 있지만 [5 6] 은 이어갈 수 없다. 

즉, **값이 작으면 작을수록**, X 가 들어왔을 때 **이어나갈 수 있는 가능성이 높아진다!**

이러한 정보를 담는 테이블 C 를 만들어놓으면, 위 예시는 다음과 같이 된다.

* 5가 들어왔을 때 -> [5]
* 6이 들어왔을 때 -> [5 6]
* 1이 들어왔을 때 -> [1 6]
* 2가 들어왔을 때 -> [1 2]
* 3(X)이 들어왔을 때 -> [1 2 3]


즉, C[i] 는 "길이가 i일때 최소인 값" 이 되고, 이를 계속 갱신해나가면 된다. 그리고 이 갱신 과정속에서, C 테이블은 **항상 정렬이 되어있다!** 

**정렬이 되어있다는 말은, 곧 내가 위로 가야할지, 아래로 가야할지 판단이 가능하다는 뜻이고, 이는 이진탐색이 가능하다는 것을 의미한다.**

### 5-B 구현

```java
public int lis4(List<Integer> V) {
    List<Integer> C = new ArrayList<>();
    C.add(0);
    
    int ret = 0;
    for (int i = 0; i < V.size(); i++) {
        if (V.get(i) > C.get(ret)) {
            ret += 1;
            C.add(V.get(i));
        } else {
            int loc = binarySearch(C, 0, ret, V.get(i));
            C.set(loc, V.get(i));
        }
    }

    return ret;
}

public int binarySearch(List<Integer> C, int low, int high, int value) {
    if (low == high) return low;

    int mid = (low + high) / 2;
    if (C.get(mid) == value) return mid;
    else if (C.get(mid) < value) return binarySearch(C, mid+1, high, value);
    else return binarySearch(C, low, mid, value);
}
```

: 함수를 두개로 나눠, 하나는 순수한 이진탐색, 하나는 위에서 설명한 과정을 구현하였다. 여기서 이진탐색까지 설명하는건 범위에서 벗어나므로, 따로 찾아보도록 하자.(오히려 Parametric Search에 가까운가 싶다.)

```java
List<Integer> C = new ArrayList<>();
C.add(0);
int ret = 0;
```

역시 구현에 앞서, 몇 가지 세팅이 필요하다.   
먼저, C 가 첫 번째 입력에도 이진탐색에 대응할 수 있도록, 0 을 넣어주자. 또한, ret이 최장증가부분수열의 길이를 나타내기도 하면서, 동시에 C 테이블의 가장 마지막 녀석의 index를 나타내기도 한다 (결국은 같은 말이다.)

즉, 앞의 이론에서 이야기한 내용을 가슴속에 품은채로 생각해보면, C 테이블의 가장 마지막에 있는 녀석은, "가장 유리하면서", 동시에 "가장 큰 값"인데, 그것보다 더 큰 녀석이 나타났다는 것은 새로운 기록을 가진 녀석이 나타난다는 뜻이 된다.

그러나, 위 조건에 성립하지 않는 녀석은 우리가 교체해야할 녀석이다. C 테이블에서 교체할 자리를 찾아서, 신규 데이터로 갱신해준다.`C.set(loc, V.get(i));`

### 5-C 시간복잡도.
: 꽤나 어려운 알고리즘이지만, 시간복잡도는 아주 깔끔하다. 각 원소를 반복하는데 N, 그리고 이분탐색하는데 logN이 더해져 최종적으로는 O(NlogN)이 된다.

# 6. 마치며
: 이 글을 읽는 분들이 기나긴 터널의 끝을 떠나 한줄기 빛을 맞이하는 기분이었으면 좋겠다. 다만, 내가 방금 공부한 내용을 글로 옮기는 것은 공부하는데에는 효과적일지 모르겠으나, 남에게 정확한 정보를 전달한다는 점에서는 아무래도 완성도가 떨어지기 마련이다. 더욱이 이렇게 장문의 글을 쓰기가 쉽지 않아, 중간중간 어디 틀렸을까 걱정되기도 한다. 잘못된 부분이 있으면 언제든 지적 바란다.

이상으로 포스팅을 마칩니다.

### Reference
- [LIS의 길이를 구하는 3가지 알고리즘](https://shoark7.github.io/programming/algorithm/3-LIS-algorithms)
- [나무위키 - 최장 증가 부분 수열](https://namu.wiki/w/%EC%B5%9C%EC%9E%A5%20%EC%A6%9D%EA%B0%80%20%EB%B6%80%EB%B6%84%20%EC%88%98%EC%97%B4)