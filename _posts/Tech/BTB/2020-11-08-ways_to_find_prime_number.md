---
layout: post
title:  "# 소수(Prime Number)를 찾는 방법 ( feat. Java )"
date:   2020-11-08 17:43:00 +0900
categories: btb
tags: 
cover: /assets/covers/coding.png
---

# 0. 들어가며
: 우아한 테크코스 코딩테스트를 준비하며, 이전에 풀었던 PS 문제들을 하나씩 둘러보던 중, 소수 문제를 발견했다. 소수를 구하는 방법에 여러 가지가 있는 것은 알았는데, 막상 쓰려니까 손가락이 잘 움직이지 않았다.

해서 생각난 김에, 이번 포스팅에서 주어진 숫자가 소수인지 확인하는 방법에 대해서  알아보고자 한다. 

# 1. 소수(Prime Number)
: 소수를 모르는 사람은 없을 것이다. 그래도 굳이 한번 적어보자면, 소수의 정의는 다음과 같다.

> **1과 자기자신 이외의 수로 나누어 떨어지지 않는, 즉 약수를 갖지 않는 자연수**

# 2. Methods to find Prime Number

## 1) Method 1
: 소수의 정의에 충실하게, n 부터 2까지 하나씩 약분해봄으로써 구할 수 있을 것이다.

```java
public static boolean isPrime(int num) {
    for (int i = 2; i < num; i++) {
        if (num % i == 0) return false;
    }

    return true;
}
```

num을 num와 2 사이의 값으로 나누었을 때 나머지 값이 0이 된다는 것은, 나누어 떨어진다는 것을 의미하고, 이는 곧 약수가 존재함을 의미하니, 소수인지 아닌지 여부를 간단하게 판별해낼 수 있다.

## 2) Method 2

: 그런데, 여기서 **한 걸음 더** 나아가보자. 어떤 주어진 수 X 에 대해서, X/2초과, X미만까지의 값을 Y라고 했을 때, `X / Y` 는 반드시 1 초과, 2 미만의 값을 가진다.

정말일까? 예시를 갖고 살펴보자.    
X를 12로 두었을 때, Y가 될 수 있는 값들은 (7, 8, 9, 10, 11)이 된다.    
(7, 8, 9, 10, 11) 을 분모로 두는, `X / Y` 는 (1.714, 1.5, ... , 1.090)인 실수가 되므로, 나누어 떨어지지 않는다.  

이를 바꿔말하면, **X/2 초과의 값은 살펴볼 필요가 없다**는 말이 된다.  
따라서 우리는 주어진 num 까지가 아닌, num/2까지만 살펴보면 된다.

```java
public static boolean isPrime(int num) {
    for (int i = 2; i <= num/2; i++) {
        if (num % i == 0) return false;
    }

    return true;
}
```

이 때 주의할 점은, num/2 를 포함해서 살펴봐야 하므로, `<` 기호가 아닌 `<=` 기호를 사용해야 한다.

## 3) Method 3

: 마지막 한걸음만 더 내딛어 보자. 사실, num/2 까지 갈 필요도 없고, sqrt(num) 까지만 살펴보면 된다. 다음의 예시를 보자.

- num이 12인 경우, sqrt(12) 는 약 3.464 이다. 이 때, 후보 (2, 3) 중 2(또는 3)를 넣는 경우 0으로 나누어 떨어진다.
- num이 13인 경우, sqrt(13) 은 약 3.606 이다. 이 때, 후보 (2, 3) 중 어느 값을 넣어도 0으로 나누어 떨어지지 않는다.

이것이 어떻게 가능한 것일까? 원리는 간단하다.

어떤 수의 약수를 쭉 나열하면, 다음과 같은 규칙을 발견할 수 있다.

1. 약수의 개수는 반드시 짝수이다.
2. index(i) , index(n-i-1) (n은 약수의 길이, i는 n보다 작은 임의의 수) 를 곱하면 원래의 수가 나온다.

즉, 가령 40 이라는 숫자의 약수는 [1, 2, 4, 5, 8, 10, 20, 40] 으로, 총 **8개(짝수)**의 약수를 갖는다. 그리고, index(0)과 index(8-0-1, 7)은 1과 40이고, 이 둘을 곱하면 원래의 수 40이 나온다. index(1)과 index(8-1-1, 6)은 2와 20이고, 이 둘을 곱하면 원래의 수 40이 나온다. 즉, pair로 묶으면, 이 약수의 리스트 중에서 **index(n/2)까지만(앞 절반만)** 살펴보면 된다.

그런데 범위를 정수가 아닌 실수로 확장시켜보면, `sqrt(n) * sqrt(n)` 이라는 실수의 약수도 있다. 즉, *억지를 부려서,* 다음과 같이 약수의 리스트를 만들 수도 있는 것이다.

[1, 2, 4, 5, 6.325, 6.325, 8, 10, 20, 40]  
 \* sqrt(40) = 6.325

즉 바꿔말하면, sqrt(n)은 약수 pair의 중앙값이 되고, 2 이상 sqrt(n) 미만의 값에 정수의 약수가 존재한다면, 이는 곧 합성수라는 의미가 된다.

잘 이해가 되지 않는다면, 다음의 예시를 보자.

- num이 65 인 경우 -> 약수는 (1, 5, 13, 65) 이고 sqrt(65)는 약 8.062 이다. 따라서, 8.062 는 5와 13 사이에 끼어들어 갈 수 있다. 그리고, 2 이상 8.062 이하의 값 중에, 5 라는 약수가 존재하므로, 합성수다.
- num이 67 인 경우 -> 약수는 (1, 67) 이다. sqrt(67) 약 8.185 는 1 과 67 사이에 끼어들어 갈 수 있다. 그리고, 2 이상 8.185 이하의 약수가 존재하지 않으므로, 소수다.

따라서, 코드로는 다음과 같이 작성할 수 있다.

```java
public static boolean isPrime(int num) {
    for (int i = 2; i <= Math.sqrt(num); i++) {
        if (num % i == 0) return false;
    }

    return true;
}
```

---

위 방법들은, 숫자가 주어졌을 때, **이것이 소수인가요?** 에 대답할 수 있는 방법들이다. 거꾸로, **소수의 목록을 주세요.** 라고 하면 어떻게 해야할까? 가령 100 까지의 소수를 달라고 하면, 2 부터 100 까지 위 isPrime()을 반복할까? 그것보다는, 소수를 한 번에 생성해놓는 것이 나을것이다. 

(2020.11.16 수정)

미리 소수를 다 생성을 해놓는 방식을 대개 체(체에 거른다 할 때의 그 체가 맞다.) 라고 부르는데, 여기에는 여러가지 방법이 있다. 

에라토스테네스, 오일러, 순다람, 앳킨... 의 체가 있는데, 에라토스테네스의 체를 제외한 나머지 방법들은 방법도 어려울뿐더러, 수학자가 아닌데 이것까지 알아야 하나 싶어서 작성을 포기하였다. 여기서는 에라토스테네스의 체만 알아보고, 나머지가 궁금한 사람은 다음의 링크를 참고하자.

- [sieve of euler](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes#Euler's_sieve)  
- [sieve of sundaram](https://www.geeksforgeeks.org/sieve-sundaram-print-primes-smaller-n/)  
- [sieve of atkin](https://www.geeksforgeeks.org/sieve-of-atkin/)

# 에라토스테네스의 체

: 에라토스테네스의 체라는, 고대의 수학자가 발견해낸 방법이 있다. 이 또한 원리는 어렵지 않은데, X 가 소수일 때, X를 제외한 나머지 X의 배수는 모두 합성수일 것은 자명하다. 따라서, 2부터 시작해서, 합성수라고 mark 되지 않은 모든 (X가 아닌) X의 배수를 합성수라고 mark 하면 된다.

이 흐름은 다음의 애니메이션으로 쉽게 이해할 수 있다.

![](/assets/images/Sieve_of_Eratosthenes_animation.gif)

코드로는 다음과 같이 작성할 수 있다.

```java
public static boolean isPrime(int num) {
    boolean[] prime = new boolean[num + 1]; //
    Arrays.fill(prime, true); // 모든 숫자가 소수라고 가정
    prime[0] = prime[1] = false; // 0과 1은 소수의 정의에서 벗어남.

    for (int i = 2; i * i <= num; i++) {
        if (prime[i]) {
            for (int j = i * i; j <= num; j += i) {
                prime[j] = false;
            }
        }
    }

    return prime[num];
}
```

잡다한 부분은 쳐내고, for loop만 보자.  

첫 번째 for문의 Math.sqrt(num) 부분은, 위에서 설명했던 부분과 같다. 그 뒷부분은 살펴볼 필요가 없다.

그리고 이 for문을 반복하면서, 어떤 숫자가 소수라고 mark 되어 있다면, 해당 숫자의 `i * i` 부터, num 까지. 즉 i의 배수를 합성수로 mark 한다. 이 때, j가 왜 `i * i` 부터 시작하는지 의문을 가질 수 있는데, `i * 2` 이상 `i * (i - 1)` 이하 에서, `2`와 `i - 1` 에 해당하는 값 k 는 이미 검사되었으므로(**즉, k 는 이전에 i 였있다.**) `i * i` 부터 시작할 수 있다.












