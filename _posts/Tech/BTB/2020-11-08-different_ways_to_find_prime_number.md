---
layout: post
title:  "# 소수(Prime Number)를 찾는 방법 [1편] ( feat. Java )"
date:   2020-11-08 17:43:00 +0900
categories: btb
tags: 
cover: /assets/covers/coding.png
---

# 0. 들어가며
: 우아한 테크코스 코딩테스트를 준비하며, 이전에 풀었던 PS 문제들을 하나씩 둘러보던 중, 소수 문제를 발견했다. 소수를 구하는 방법에 여러 가지가 있는 것은 알았는데, 막상 쓰려니까 손가락이 잘 움직이지 않았다.

해서 생각난 김에, 이번 1편에서는 주어진 숫자가 소수인지 확인하는 방법에 대해서 먼저 알아보고자 한다. 

# 1. 소수(Prime Number)
: 소수를 모르는 사람은 없을 것이다. 그래도 굳이 한번 적어보자면, 소수의 정의는 다음과 같다.

> **1과 자기자신 이외의 수로 나누어 떨어지지 않는, 즉 약수를 갖지 않는 자연수**

# 2. Methods to find Prime Number

## 1) Method 1
: 소수의 정의에 충실하게, n 부터 2까지 하나씩 약분해봄으로써 구할 수 있을 것이다.

```java
public static boolean isPrime(int num) {
    for (int i = 2; i < num; i++) {
        if (num % i == 0) return false;
    }

    return true;
}
```

num을 num와 2 사이의 값으로 나누었을 때 나머지 값이 0이 된다는 것은, 나누어 떨어진다는 것을 의미하고, 이는 곧 약수가 존재함을 의미하니, 소수인지 아닌지 여부를 간단하게 판별해낼 수 있다.

## 2) Method 2

: 그런데, 여기서 **한 걸음 더** 나아가보자. 어떤 주어진 수 X 에 대해서, X/2초과, X미만까지의 값을 Y라고 했을 때, `X / Y` 는 반드시 1 초과, 2 미만의 값을 가진다.

정말일까? 예시를 갖고 살펴보자.    
X를 12로 두었을 때, Y가 될 수 있는 값들은 (7, 8, 9, 10, 11)이 된다.    
(7, 8, 9, 10, 11) 을 분모로 두는, `X / Y` 는 (1.714, 1.5, ... , 1.090)인 실수가 되므로, 나누어 떨어지지 않는다.  

이를 바꿔말하면, **X/2 초과의 값은 살펴볼 필요가 없다**는 말이 된다.  
따라서 우리는 주어진 num 까지가 아닌, num/2까지만 살펴보면 된다.

```java
public static boolean isPrime(int num) {
    for (int i = 2; i <= num/2; i++) {
        if (num % i == 0) return false;
    }

    return true;
}
```

이 때 주의할 점은, num/2 를 포함해서 살펴봐야 하므로, `<` 기호가 아닌 `<=` 기호를 사용해야 한다.

## 3) Method 3

: 마지막 한걸음만 더 내딛어 보자. 사실, num/2 까지 갈 필요도 없고, sqrt(num) 까지만 살펴보면 된다. 다음의 예시를 보자.

- num이 12인 경우, sqrt(12) 는 약 3.464 이다. 이 때, 후보 (2, 3) 중 2(또는 3)를 넣는 경우 0으로 나누어 떨어진다.
- num이 13인 경우, sqrt(13) 은 약 3.606 이다. 이 때, 후보 (2, 3) 중 어느 값을 넣어도 0으로 나누어 떨어지지 않는다.

이것이 어떻게 가능한 것일까? 원리는 간단하다.

어떤 수의 약수를 쭉 나열하면, 다음과 같은 규칙을 발견할 수 있다.

1. 약수의 개수는 반드시 짝수이다.
2. index(i) , index(n-i-1) (n은 약수의 길이, i는 n보다 작은 임의의 수) 를 곱하면 원래의 수가 나온다.

즉, 가령 40 이라는 숫자의 약수는 [1, 2, 4, 5, 8, 10, 20, 40] 으로, 총 **8개(짝수)**의 약수를 갖는다. 그리고, index(0)과 index(8-0-1, 7)은 1과 40이고, 이 둘을 곱하면 원래의 수 40이 나온다. index(1)과 index(8-1-1, 6)은 2와 20이고, 이 둘을 곱하면 원래의 수 40이 나온다. 즉, pair로 묶으면, 이 약수의 리스트 중에서 **index(n/2)까지만(앞 절반만)** 살펴보면 된다.

그런데 범위를 정수가 아닌 실수로 확장시켜보면, `sqrt(n) * sqrt(n)` 이라는 실수의 약수도 있다. 즉, *억지를 부려서,* 다음과 같이 약수의 리스트를 만들 수도 있는 것이다.

[1, 2, 4, 5, 6.325, 6.325, 8, 10, 20, 40]  
 \* sqrt(40) = 6.325

즉 바꿔말하면, sqrt(n)은 약수 pair의 중앙값이 되고, 2 이상 sqrt(n) 미만의 값에 정수의 약수가 존재한다면, 이는 곧 합성수라는 의미가 된다.

잘 이해가 되지 않는다면, 다음의 예시를 보자.

- num이 65 인 경우 -> 약수는 (1, 5, 13, 65) 이고 sqrt(65)는 약 8.062 이다. 따라서, 8.062 는 5와 13 사이에 끼어들어 갈 수 있다. 그리고, 2 이상 8.062 이하의 값 중에, 5 라는 약수가 존재하므로, 합성수다.
- num이 67 인 경우 -> 약수는 (1, 67) 이다. sqrt(67) 약 8.185 는 1 과 67 사이에 끼어들어 갈 수 있다. 그리고, 2 이상 8.185 이하의 약수가 존재하지 않으므로, 소수다.

따라서, 코드로는 다음과 같이 작성할 수 있다.

```java
public static boolean isPrime(int num) {
    for (int i = 2; i <= Math.sqrt(num); i++) {
        if (num % i == 0) return false;
    }

    return true;
}
```

---

위 방법들은, 숫자가 주어졌을 때, **이것이 소수인가요?** 에 대답할 수 있는 방법들이다. 거꾸로, **소수의 목록을 주세요.** 라고 하면 어떻게 해야할까? 가령 100 까지의 소수를 달라고 하면, 2 부터 100 까지 위 isPrime()을 반복할까? 그것보다는, 소수를 한 번에 생성해놓는 것이 나을것이다. 

따라서, 다음 2편에서 이 **소수의 목록**을 구할 수 있는, 4 가지의 체(sieve) 방식 - [에라토스테네스, 오일러, 순다람, 앳킨]에 대해서 살펴보자. 이상으로 포스팅을 마칩니다.











