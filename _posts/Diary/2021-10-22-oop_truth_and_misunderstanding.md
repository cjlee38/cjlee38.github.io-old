---
layout: post
title:  "# 객체지향의 사실과 오해를 읽고, 짧은 감상문"
date: 2021-10-22 22:13:50 +0900
categories: diary
tags: 
author: cjlee
cover: /assets/covers/diary.jpg
---

![](../../assets/images/2021-10-30-00-57-59.png)

# 0. 계기
코드를 작성하면서 언제나 들었던 고민은 "더러워보인다" 였습니다. 누구도 아닌 나 스스로가 작성한 코드이니, 해결책 또한 마땅히 보이지 않았습니다. 

이보다 더 문제인 점은, 가끔은 한참을 고민하면 어디를 수정해야 할지 발견해낼 수 있었으나, 대부분의 경우 "이 클래스에 이 메소드가 있는 것이 맞는가?" "이 메소드가 이 파라미터를 필요로 하는 것이 맞는가?" 와 같이, 정답이 없는 문제들이었습니다.

더더욱 문제인 점은, 저에게는 이러한 고민에 대해서 조언해줄 사람을 찾기가 어렵다는 점입니다. 개발자에 대한 관심이 쏠리면서, 특정 기술, 프레임워크, 라이브러리에 대해서는 수많은 인터넷 강의, 블로그 자료가 영어는 물론 한국어로도 쏟아져 나옵니다.

하지만 "좋은 코드"를 작성하는 방법은 정량적으로 측정할 수 없기 때문에, 어디를 찾아봐도 "반드시 이렇게 작성해야 한다." 라는 지표를 내세우는 사람은 없습니다. 

이러한 고민을 하던 와중, 복잡한 머릿속을 좀 정리시켜줄 수 있을까 해서 `객체지향의 사실과 오해`를 구매하게 되었습니다.

# 1. 서술적 관점
이 책의 저자이신 조영호님도 서문에서 다음과 같이 이야기합니다.

> 이 책은 객체지향이란 무엇인가라는 원론적이면서도 다소 위험스러운 질문에 대한 제 나름의 대답을 말씀드리기 위해 쓰여졌습니다.  
... 중략 ...   
책을 덮은 후 여러분들이 지금까지 해왔던 방식을 뒤돌아보면서 깊은 사색에 잠길 수만 있다면 이 책은 그 목적을 다한 것이라고 생각합니다.

이 책에는 코드가 거의 나오지 않습니다. 중간에 짤막하게 예시로, 예금이라는 주제로 코드를 설계하고 작성하는 과정을 보여주지만, 핵심은 코드가 아닙니다. 개인적으로 느끼기에 이 책이 독자에게 제공하고자 하는 것은 `사상`입니다.

책은 계속해서 비슷한 이야기를 들려줍니다. `클래스는 객체가 아니다.` `객체지향의 본질은 자율적인 객체가 서로 협력하는 것이다` 등의 이야기를 반복해서 소개합니다. 

따라서 이 책을 통해 저자는 다양한 코드를 보여주기보다, 큰 개념의 원칙을 바탕으로, 다양한 관점의 추상적이고 모호한 규칙을 시사하면서, 객체지향적인 코드를 작성하는 법을 `체화`시켜주고자 합니다.

# 2. 사상적 관점
책에서는 여러 키워드(e.g. 책임, 협력, 메시징 등)가 등장하고, 위에서 언급했듯 여러 관점에서 객체간의 관계, 존재 의의를 살펴봅니다. 하지만 저는 아직 쥐뿔도 모르기에, 다음과 같은 몇 가지 문장으로 정리해보았습니다.

## 0. 본질을 잊지 말 것.
절차지향이던, 객체지향이던, 함수형이던 여러 프로그래밍 패러다임이 있고, 저마다의 특징, 장단점 또한 존재합니다. 그 와중에, 객체지향이 왜 유명하고, 많이 쓰일까요? 

책에는 "세상을 자율적이고 독립적인 객체들로 분해할 수 있는 인간의 기본적인 인지 능력으로 인해, 많은 사람들이 객체지향을 직관적이고 이해하기 쉽다고 말한다" 는 내용이 있습니다. 그렇다면, 객체지향이 직관적이고 쉽게 이해할 수 있기에 "어떤 효용성이 있는지"를 생각해봐야 할 것 같습니다. 

제가 갖고 있는 소견은, "쉬운 변경" 입니다. 그렇기에 저는 일단 코드를 설계하고, 작성할 때 "이 부분이 바뀌면 어떡하지? 어떻게 하면 쉽게 교체할 수 있을까?" 를 최우선으로 생각합니다. 이러한 생각은 `Scalable` 이라는 키워드나, `결합도, 응집도`와 같은 표현으로도 설명될 수 있을 것 같습니다.

## 1. 객체지향은 현실세계의 은유
객체지향의 세계에서는 현실 세계와 조금 다릅니다. 현실 세계에서는 내가 물컵을 들고 마시면, 물의 양이 줄어듭니다. 하지만 객체지향의 세계는 내가 물컵에게 "마신다" 라는 메시지를 보내고, 물컵은 메시지에 따라 스스로의 양을 줄입니다. 이러한 관점은 조금 이상해보입니다.

하지만 휴대폰의 버튼을 생각해보면 고개를 끄덕이게 됩니다. 우리가 휴대폰의 볼륨 버튼을 누르면, 볼륨이 줄어드는걸까요, 아니면 휴대폰이 버튼의 눌림이라는 메시지를 통해 스스로의 볼륨을 줄이는 걸까요? 제 생각에는 아무래도 후자에 가까워 보입니다.

객체지향이라고 명칭하는, 내가 창조하는 소프트웨어 세계에서는 모든 것이 살아 숨쉬는 생명체입니다.

## 2. "해줘"
객체는 해당 객체가 수행해야 할 책임이 있습니다. 식당을 예시로 생각해봅시다.

식당에서 손님이라는 객체는 음식을 시키고, 먹고, 돈을 지불할 책임이 있습니다. 식당 주인이라는 객체는 주문을 받고, 음식을 조리하고, 계산 처리를 해줄 의무가 있습니다.

그렇다면 이를 코드로 표현하면 어떨까요? 아마 다음과 같은 상상을 해볼 수 있을 것 같습니다.

```java
public class Customer {
	public void order() {
		Owner owner = new RestaurantOwner();
		owner.order(Food.JIN_RAMEN);
	}
}
```

제 눈에 이러한 코드는 굉장히 자연스럽고 당연하게 보입니다. 하지만 많은 사람들이 다음과 같이 쓰지는 않습니다.

```java
public class Customer {
	public void order() {
		Owner owner = new RestaurantOwner();
		owner.set_pot("양은"); // 양은 냄비 준비
		owner.pour_water("양은", "생수", 550); // 양은 냄비에 550ml 생수 채우기
		owner.fire_on(3); // 3번 화구 불 킴
		...
	}
}
```

분명 위와 같은 코드로도 동작은 하겠지만, 분명히 비정상적인 상황입니다. 우리는 절대 식당에서 "양은 냄비로 준비해서, 550ml의 물을 담아서 3번 화구에서 끓여주세요" 라고 요청하지 않습니다. 왜일까요?

첫 째는, 우리는 그러한 권리, 즉 책임이 없기 때문입니다. 상황에 따라 적절하게 파를 많이 넣어달라던지 등의 추가 요청은 있을 수 있지만, 대개 손님은 식당에서 맛있는 요리가 나오기를 기대할 뿐입니다.

둘 째는, 우리는 그 식당에 무슨 냄비가 있는지, 무슨 물을 쓰는지, 화구는 몇 개가 있는지따위는 알지 못하기 때문입니다. 저런 요청이 올 때마다 모두 검증해야 하기 때문입니다. 아마 다음과 같이 상상해볼 수 있겠죠.
```java
public class RestaurantOwner implements Owner {
	
	String pots[] = {"스테인리스", "알루미늄"}

	public void set_pot(String pot_type) {
		validate_pot(pot_type)
		...
	}

	private void validate_pot(String pot_type) {
		for (String pot : pots) {
			if (pot.equals(pot_type))
				return ;
		}
		raise IllegalArgumentException("그건 없는데요 손님?")
	}
}
```

## 3. 맡은 바는 충실하게
식당에서 라면을 주문했는데, 식당 주인의 실수로 계란을 빠트렸습니다. 손님은 라면을 먹다가 계란이 없다는 사실을 발견하고 식당 주인에게 항의합니다.

현실에서는 항의정도로 그쳐서 그나마 다행이지만, 소프트웨어 세계에서는 프로그램이 죽어버릴 수도 있습니다. 명백히 기대한 바와 다른 결과이기 때문이죠. 방문하는 손님은 음식이 완벽하게 조리되어 나오기를 기대하기 때문에, 이러한 상황은 발생해서는 안됩니다.

이동욱님의 블로그 포스팅 중, [일급 컬렉션](https://jojoldu.tistory.com/412?category=635881) 에서는 비즈니스 로직을 서비스 메소드에서 처리하지 않고, 이를 객체화 하여 스스로 검증 로직을 갖도록 만듭니다. (잠깐 멈추고 한번 읽어보고 오시는 것도 좋습니다.)

식당 예시에서는, 이러한 검증 로직은 최소 `라면` 객체가, 그게 아니라면 아무리 못해도 최소한 `식당 주인`이 갖고 있어서 온전한 라면을 손님에게 제공해야 합니다. `손님` 이라는 객체가 검증하는 것은 명백히 잘못된 상황입니다.

## 4. 적절한 추상화
우리가 어떤 클래스, 메소드, 변수 등에 대해서 이름을 정할 때, 본능적으로 관련이 있는 단어를 사용합니다. 메소드로 생각해보면, `a()` `b()` 와 같은 짓은 하지 않죠. 왜? 이 함수가 무슨 일을 하는지 한번에 떠올리지 못하기 때문입니다. 내가 쓴 코드지만 며칠이 지나면 까먹어버리니까요.

그렇다면 `public void get()` `public void set()`은 어떤가요? 간단한 객체를 리턴하는 정도면 무리가 없어보이지만, 만약 파일을 읽고, 그 안에서 뭔가 수정하고, 변경하고, 필터링을 거치는 등의 많은 작업이 일어나면, 이러한 단어로 내용을 모두 함축시키는 것은 조금 무리가 있어보입니다.

말인 즉슨, 안에서 너무 많은 일이 일어나고 있다는 뜻인데요. 단순히 메소드를 나눈다고 할 지라도, 하나의 클래스가 너무 많은 역할을 담당하고 있습니다. 이럴 때 그 중간 지점을 찾아내서, 추상화가 필요합니다.

```java
public class RestaurantOwner implements Owner {
	
	List<Stove> stoves = new ArrayList<>();

	public Ramen cook_ramen(...) {
		Pot pot = new Pot("양은");
		pot.pour(550);
		stoves.get(3).put_on(pot);
		...
	}

	public Udon cook_udon(...) {
		Pot pot = new Pot("양은");
		pot.pour(400);
		stoves.get(1).put_on(pot);
		...
	}
}
```
요리사 라면과 우동을 조리하는 것은 현실에선 자연스러워 보이지만, 관점을 조금 바꿔보면 다음과 같이 작성할 수 있습니다.

```java
public class RestaurantOwner implements Owner {

	public Food cook(FoodMenu menu) {
		Food food = Food.of(menu);
		return food;
	}
}
```

사실 생각해보면, 우리가 메뉴판을 보고 라면을 "조리해달라", 우동을 "조리해달라" 라고 이야기하지, 메뉴판도 보지 않고 "라면을 조리해주세요", "우동을 조리해주세요" 라고 이야기 하지 않습니다.

`메소드가 한 가지 일만을 해야한다`, `단일책임원칙` 과 같은 문장은 아마 이와 같은 맥락에서 이야기하는 것이라 생각합니다. 

## 5. 기타.
1. 한 번에 좋은 코드를 작성하려고 하지 말 것. 설계는 코드를 작성하는 도중에 반드시 바뀐다. 설계를 최대한 빨리 마치고 코드 작성을 들어가야 한다.

> ... 작성중


# 3. 마무리
아직 많은 코드를 작성하고, 다양한 문제에 맞닥뜨려본 경험이 없어 많은 내용을 이해하진 못했고, 또 제가 이해한 내용이 틀렸을 수도 있습니다. 나중에 기회가 된다면 다시 한번 펴볼만한 가치가 차고 넘치는 책이라 생각합니다.

저와 비슷한 고민을 하고 있는 분들은 이 책을 꼭 한번 구매해보시기를 추천드립니다. 저는 조영호님의 다른 책인 `오브젝트`를 주문하러 가보겠습니다. 감사합니다.
